[
    {
        "identifier": "27_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nbasket_for_clothes, id: 1000, properties: ['CAN_OPEN', 'CONTAINERS', 'MOVABLE', 'GRABBABLE']\nwashing_machine, id: 1001, properties: ['CONTAINERS', 'HAS_PLUG', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\nsoap, id: 1002, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nclothes_jacket, id: 1003, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\n-----------------\n\n\nThe current environment state is\nNodes:\nwashing_machine, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_PLUG', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\n\nEdges:\n<basket_for_clothes> (1000) is NEAR to <soap> (1002)\n<basket_for_clothes> (1000) is NEAR to <clothes_jacket> (1003)\n<character> (65) is INSIDE to <bathroom> (1)\n<soap> (1002) is NEAR to <basket_for_clothes> (1000)\n<clothes_jacket> (1003) is NEAR to <basket_for_clothes> (1000)\n<clothes_jacket> (1003) is INSIDE to <washing_machine> (1001)\n-----------------\n\n\nNode goals are:\nwashing_machine is CLOSED\nwashing_machine is ON\nwashing_machine is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nclothes_jacket is ON to washing_machine\nsoap is ON to washing_machine\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "417_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nwashing_machine, id: 1000, properties: ['CONTAINERS', 'HAS_PLUG', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\nclothes_pants, id: 1001, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nclothes_pants, id: 1002, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nclothes_shirt, id: 1003, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nclothes_shirt, id: 1004, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nsoap, id: 1005, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nwashing_machine, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_PLUG', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\n\nEdges:\n<soap> (1005) is INSIDE to <washing_machine> (1000)\n<clothes_pants> (1001) is INSIDE to <washing_machine> (1000)\n<clothes_shirt> (1003) is INSIDE to <washing_machine> (1000)\n<clothes_shirt> (1004) is INSIDE to <washing_machine> (1000)\n<clothes_pants> (1002) is INSIDE to <washing_machine> (1000)\n-----------------\n\n\nNode goals are:\nwashing_machine is CLOSED\nwashing_machine is ON\nwashing_machine is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nclothes_pants is ON to washing_machine\nclothes_shirt is ON to washing_machine\nclothes_shirt is ON to washing_machine\nclothes_pants is ON to washing_machine\nsoap is ON to washing_machine\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "850_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwashing_machine, id: 1000, properties: ['CONTAINERS', 'HAS_PLUG', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\ndining_room, id: 201, properties: []\nlaundry_detergent, id: 1002, properties: ['MOVABLE', 'GRABBABLE', 'POURABLE']\nclothes_pants, id: 1001, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\n-----------------\n\n\nThe current environment state is\nNodes:\nwashing_machine, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_PLUG', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\n\nEdges:\n<clothes_pants> (1001) is INSIDE to <washing_machine> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nwashing_machine is CLOSED\nwashing_machine is ON\nwashing_machine is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nclothes_pants is ON to washing_machine\nlaundry_detergent is ON to washing_machine\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "954_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwashing_machine, id: 1001, properties: ['CONTAINERS', 'HAS_PLUG', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\nclothes_dress, id: 1002, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nclothes_pants, id: 1003, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nclothes_shirt, id: 1004, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nclothes_underwear, id: 1005, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nsoap, id: 1006, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nwashing_machine, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_PLUG', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\n\nEdges:\n<clothes_underwear> (1005) is INSIDE to <washing_machine> (1001)\n<soap> (1006) is INSIDE to <washing_machine> (1001)\n<clothes_dress> (1002) is INSIDE to <washing_machine> (1001)\n<character> (65) is INSIDE to <home_office> (319)\n<clothes_shirt> (1004) is INSIDE to <washing_machine> (1001)\n<clothes_pants> (1003) is INSIDE to <washing_machine> (1001)\n-----------------\n\n\nNode goals are:\nwashing_machine is CLOSED\nwashing_machine is ON\nwashing_machine is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nclothes_shirt is ON to washing_machine\nclothes_pants is ON to washing_machine\nclothes_underwear is ON to washing_machine\nsoap is ON to washing_machine\nclothes_dress is ON to washing_machine\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "11_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "120_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "125_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['OFF', 'PLUGGED_OUT', 'CLEAN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "150_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "160_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncontroller, id: 1000, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nlight, id: 1002, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncontroller, id: 1001, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "180_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "205_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "222_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "232_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 1001, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "310_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "311_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "331_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "339_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "345_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nhome_office, id: 319, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nfiling_cabinet, id: 399, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<filing_cabinet> (399) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <filing_cabinet> (399)\n<remote_control> (1000) is ON to <filing_cabinet> (399)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "392_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nlight, id: 64, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "394_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "432_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "443_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "445_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nlight, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "511_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "585_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG']\nfloor_lamp, id: 1001, properties: ['HAS_SWITCH', 'MOVABLE']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "604_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nlight, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nlight, id: 64, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "616_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nlight, id: 64, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "627_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "705_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "708_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "715_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\nlight, states: ['OFF', 'PLUGGED_OUT', 'CLEAN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "737_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "780_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "812_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "835_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "85_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "874_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbedroom, id: 67, properties: []\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "491_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntoothbrush, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT']\ndining_room, id: 201, properties: []\ntooth_paste, id: 1001, properties: ['CREAM', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to tooth_paste\ncharacter is HOLDS_RH to toothbrush\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "696_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nbathroom, id: 1, properties: []\ncharacter, id: 65, properties: []\ntooth_paste, id: 1000, properties: ['CREAM', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE', 'POURABLE']\ntoothbrush, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<tooth_paste> (1000) is NEAR to <toothbrush> (1001)\n<character> (65) is INSIDE to <home_office> (319)\n<toothbrush> (1001) is NEAR to <tooth_paste> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to toothbrush\ncharacter is HOLDS_RH to tooth_paste\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1003_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nwalllamp, id: 351, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <cpuscreen> (416)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<keyboard> (415) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (326)\n<chair> (356) is NEAR to <mouse> (413)\n<wall> (213) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <floor> (326)\n<mouse> (413) is NEAR to <wall> (213)\n<keyboard> (415) is NEAR to <computer> (417)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<keyboard> (415) is NEAR to <walllamp> (351)\n<mouse> (413) is NEAR to <chair> (356)\n<floor> (325) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <floor> (208)\n<computer> (417) is NEAR to <keyboard> (415)\n<chair> (356) is NEAR to <keyboard> (415)\n<floor> (326) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <wall> (331)\n<keyboard> (415) is NEAR to <wall> (330)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n<keyboard> (415) is ON to <desk> (357)\n<mouse> (413) is NEAR to <floor> (325)\n<keyboard> (415) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<wall> (331) is NEAR to <keyboard> (415)\n<floor> (326) is NEAR to <keyboard> (415)\n<walllamp> (351) is NEAR to <keyboard> (415)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<character> (65) is INSIDE to <bedroom> (67)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <wall> (213)\n<mousepad> (414) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<cpuscreen> (416) is NEAR to <keyboard> (415)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <desk> (357)\n<wall> (330) is NEAR to <keyboard> (415)\n<desk> (357) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<wall> (213) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <wall> (330)\n<keyboard> (415) is NEAR to <floor> (325)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\nSWITCHOFF\nSWITCHOFF\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "115_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "407_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nhome_office, id: 319, properties: []\naddress_book, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "430_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "481_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbathroom, id: 1, properties: []\nmail, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE']\nbutton, id: 1001, properties: ['MOVABLE', 'GRABBABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\nSWITCHOFF\nSWITCHOFF\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "622_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nhome_office, id: 319, properties: []\ndining_room, id: 201, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\nmouse, states: ['PLUGGED_OUT', 'CLEAN'], properties:['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nkeyboard, states: ['PLUGGED_OUT', 'CLEAN'], properties:['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "699_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nhome_office, id: 319, properties: []\nmail, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE']\ncheck, id: 1001, properties: ['HAS_PAPER', 'MOVABLE', 'GRABBABLE', 'READABLE']\ndining_room, id: 201, properties: []\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nmail, states: ['CLOSED', 'CLEAN'], properties:['READABLE', 'HAS_PAPER', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE']\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<check> (1001) is NEAR to <chair> (356)\n<chair> (356) is NEAR to <check> (1001)\n<check> (1001) is INSIDE to <mail> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "824_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "87_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nlaptop, id: 1000, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlaptop, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <laptop> (1000)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <wall> (213)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<laptop> (1000) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (208)\n<floor> (326) is NEAR to <mouse> (413)\n<character> (65) is INSIDE to <dining_room> (201)\n<mouse> (413) is ON to <mousepad> (414)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<mouse> (413) is NEAR to <wall> (330)\n-----------------\n\n\nNode goals are:\nlaptop is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "986_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nhair, id: 2012, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\nSWITCHOFF\nSWITCHOFF\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "996_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nchair, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ncomputer, id: 1001, properties: ['HAS_SWITCH', 'LOOKABLE']\nkeyboard, id: 1002, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1004_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfood_food, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nfood_food is INSIDE to freezer\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "152_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nfood_food, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nfood_food is INSIDE to freezer\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "298_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncharacter, id: 65, properties: []\nfood_food, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nfood_food is INSIDE to freezer\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "609_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nfood_food, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "703_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfood_food, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nfood_food is INSIDE to freezer\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "772_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nmilk, id: 1000, properties: ['DRINKABLE', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE', 'POURABLE']\nfood_turkey, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nfood_egg, id: 1002, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nfood_egg, id: 1003, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nfood_egg, id: 1004, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nfood_fish, id: 1005, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nfood_chicken, id: 1006, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "837_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\ncolander, id: 2003, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT']\nfood_food, id: 2004, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncoffe_maker, id: 290, properties: ['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\ntoaster, id: 292, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE']\nkitchen_counter, id: 230, properties: ['SURFACES']\nfaucet, id: 232, properties: ['HAS_SWITCH']\nfood_cheese, id: 1001, properties: ['CREAM', 'GRABBABLE', 'EATABLE', 'MOVABLE', 'CUTTABLE']\nmilk, id: 1002, properties: ['DRINKABLE', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE', 'POURABLE']\nfood_vegetable, id: 1003, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nfood_egg, id: 1004, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nmicrowave, id: 297, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\nfood_food, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<kitchen_counter> (230) is NEAR to <food_egg> (1004)\n<food_cheese> (1001) is NEAR to <kitchen_counter> (230)\n<kitchen_counter> (230) is NEAR to <food_cheese> (1001)\n<kitchen_counter> (230) is NEAR to <milk> (1002)\n<milk> (1002) is NEAR to <kitchen_counter> (230)\n<character> (65) is INSIDE to <bedroom> (67)\n<food_vegetable> (1003) is NEAR to <kitchen_counter> (230)\n<food_egg> (1004) is NEAR to <kitchen_counter> (230)\n<kitchen_counter> (230) is NEAR to <food_vegetable> (1003)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nfood_cheese is INSIDE to freezer\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "158_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntoilet, id: 37, properties: ['CONTAINERS', 'CAN_OPEN', 'SITTABLE']\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is INSIDE to bathroom\ncharacter is FACING to toilet\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "323_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntoilet, id: 37, properties: ['CONTAINERS', 'CAN_OPEN', 'SITTABLE']\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntoilet, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN', 'SITTABLE']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is ON to toilet\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "430_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntoilet, id: 37, properties: ['CONTAINERS', 'CAN_OPEN', 'SITTABLE']\ntoilet_paper, id: 1000, properties: ['HAS_PAPER', 'GRABBABLE', 'COVER_OBJECT', 'MOVABLE', 'HANGABLE', 'CUTTABLE']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nbathroom_counter, id: 41, properties: ['SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n<toilet_paper> (1000) is NEAR to <toilet> (37)\n<toilet> (37) is NEAR to <toilet_paper> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is ON to toilet\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "478_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntoilet, id: 37, properties: ['CONTAINERS', 'CAN_OPEN', 'SITTABLE']\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is ON to toilet\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "496_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntoilet, id: 37, properties: ['CONTAINERS', 'CAN_OPEN', 'SITTABLE']\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is INSIDE to bathroom\ncharacter is FACING to toilet\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "624_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ntoilet, id: 1000, properties: ['CONTAINERS', 'CAN_OPEN', 'SITTABLE']\ncharacter, id: 65, properties: []\ndresser, id: 108, properties: ['CONTAINERS', 'CAN_OPEN']\ntoilet_paper, id: 1001, properties: ['HAS_PAPER', 'GRABBABLE', 'COVER_OBJECT', 'MOVABLE', 'HANGABLE', 'CUTTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<toilet> (1000) is NEAR to <toilet_paper> (1001)\n<toilet_paper> (1001) is NEAR to <toilet> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is ON to toilet\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "188_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\ncharacter is HOLDS_RH to remote_control\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH or PUSH\nTOUCH|PUSH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "803_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhair, id: 2004, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to remote_control\ncharacter is HOLDS_RH to remote_control\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH or PUSH\nTOUCH|PUSH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "960_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\ncharacter is HOLDS_RH to remote_control\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH or PUSH\nTOUCH|PUSH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "101_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1068_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "153_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "196_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "198_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <wall> (213)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (208)\n<floor> (326) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<character> (65) is INSIDE to <bathroom> (1)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<mouse> (413) is NEAR to <wall> (330)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "201_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "232_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "234_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <wall> (213)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (208)\n<floor> (326) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<character> (65) is INSIDE to <bedroom> (67)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<mouse> (413) is NEAR to <wall> (330)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "343_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 75, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 207, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 210, properties: []\nwall, id: 83, properties: []\nwall, id: 84, properties: []\nmouse, id: 166, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nchair, id: 103, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nkeyboard, id: 168, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncomputer, id: 170, properties: ['HAS_SWITCH', 'LOOKABLE']\nbookshelf, id: 233, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\ncpuscreen, id: 171, properties: []\ndesk, id: 104, properties: ['MOVABLE', 'SURFACES']\nmousepad, id: 167, properties: ['MOVABLE', 'SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<cpuscreen> (171) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <wall> (210)\n<keyboard> (168) is NEAR to <floor> (76)\n<keyboard> (168) is NEAR to <light> (169)\n<keyboard> (168) is NEAR to <bookshelf> (233)\n<floor> (75) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <computer> (170)\n<desk> (104) is NEAR to <keyboard> (168)\n<chair> (103) is NEAR to <keyboard> (168)\n<floor> (207) is NEAR to <keyboard> (168)\n<floor> (76) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <floor> (207)\n<wall> (209) is NEAR to <keyboard> (168)\n<mousepad> (167) is NEAR to <keyboard> (168)\n<computer> (170) is NEAR to <keyboard> (168)\n<mouse> (166) is NEAR to <keyboard> (168)\n<light> (169) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <mouse> (166)\n<keyboard> (168) is NEAR to <chair> (103)\n<wall> (210) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <wall> (209)\n<keyboard> (168) is ON to <desk> (104)\n<keyboard> (168) is NEAR to <wall> (83)\n<keyboard> (168) is NEAR to <floor> (75)\n<bookshelf> (233) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <cpuscreen> (171)\n<keyboard> (168) is NEAR to <desk> (104)\n<wall> (84) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <wall> (84)\n<wall> (83) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <mousepad> (167)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "373_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "406_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nkeyboard, id: 168, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ncomputer, id: 170, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 103, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "409_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "419_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\nhair, id: 2008, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "433_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nmouse, id: 166, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nchair, id: 103, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nkeyboard, id: 168, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncomputer, id: 170, properties: ['HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "437_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nhair, id: 2014, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <wall> (213)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (208)\n<floor> (326) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<character> (65) is INSIDE to <bathroom> (1)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<mouse> (413) is NEAR to <wall> (330)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "440_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nmouse, id: 166, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nchair, id: 103, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 104, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 168, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncomputer, id: 170, properties: ['HAS_SWITCH', 'LOOKABLE']\nmousepad, id: 167, properties: ['MOVABLE', 'SURFACES']\ncpuscreen, id: 171, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "453_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "46_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <wall> (213)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (208)\n<floor> (326) is NEAR to <mouse> (413)\n<character> (65) is INSIDE to <dining_room> (201)\n<mouse> (413) is ON to <mousepad> (414)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<mouse> (413) is NEAR to <wall> (330)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "475_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "503_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <wall> (213)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (208)\n<floor> (326) is NEAR to <mouse> (413)\n<character> (65) is INSIDE to <dining_room> (201)\n<mouse> (413) is ON to <mousepad> (414)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<mouse> (413) is NEAR to <wall> (330)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "670_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nwalllamp, id: 351, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\ncharacter, states: [], properties:[]\ndesk, states: ['CLOSED', 'CLEAN'], properties:['MOVABLE', 'SURFACES']\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nmouse, states: ['PLUGGED_OUT', 'CLEAN'], properties:['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nkeyboard, states: ['PLUGGED_OUT', 'CLEAN'], properties:['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <cpuscreen> (416)\n<computer> (417) is NEAR to <mouse> (413)\n<light> (411) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <chair> (356)\n<mouse> (413) is ON to <desk> (357)\n<mouse> (413) is NEAR to <floor> (326)\n<chair> (356) is NEAR to <mouse> (413)\n<wall> (213) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <floor> (326)\n<mouse> (413) is NEAR to <wall> (213)\n<keyboard> (415) is NEAR to <computer> (417)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<keyboard> (415) is NEAR to <walllamp> (351)\n<mouse> (413) is NEAR to <chair> (356)\n<floor> (325) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <floor> (208)\n<computer> (417) is NEAR to <keyboard> (415)\n<chair> (356) is NEAR to <keyboard> (415)\n<floor> (326) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <light> (411)\n<keyboard> (415) is NEAR to <wall> (331)\n<keyboard> (415) is NEAR to <wall> (330)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n<mouse> (413) is NEAR to <floor> (325)\n<keyboard> (415) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<wall> (331) is NEAR to <keyboard> (415)\n<floor> (326) is NEAR to <keyboard> (415)\n<walllamp> (351) is NEAR to <keyboard> (415)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<character> (65) is INSIDE to <bedroom> (67)\n<mouse> (413) is INSIDE to <desk> (357)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <light> (411)\n<mouse> (413) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <wall> (213)\n<mousepad> (414) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<cpuscreen> (416) is NEAR to <keyboard> (415)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<wall> (330) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<light> (411) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<wall> (213) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <wall> (330)\n<keyboard> (415) is NEAR to <floor> (325)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "719_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "757_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nkeyboard, id: 168, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ncomputer, id: 170, properties: ['HAS_SWITCH', 'LOOKABLE']\nmouse, id: 166, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "787_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nhome_office, id: 319, properties: []\ndining_room, id: 201, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "795_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nchair, id: 103, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nkeyboard, id: 168, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncomputer, id: 170, properties: ['HAS_SWITCH', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "819_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nhair, id: 2004, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "874_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "910_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "91_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <wall> (213)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (208)\n<floor> (326) is NEAR to <mouse> (413)\n<character> (65) is INSIDE to <dining_room> (201)\n<mouse> (413) is ON to <mousepad> (414)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<mouse> (413) is NEAR to <wall> (330)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "93_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\ncheck, id: 1000, properties: ['HAS_PAPER', 'MOVABLE', 'GRABBABLE', 'READABLE']\nhomework, id: 1001, properties: ['HAS_PAPER', 'MOVABLE', 'GRABBABLE', 'READABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nhair, id: 2005, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "962_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbutton, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "190_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nbowl, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT']\ndishwasher, id: 1001, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\nplate, id: 1002, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndish_soap, id: 1003, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<dish_soap> (1003) is INSIDE to <dishwasher> (1001)\n<character> (65) is INSIDE to <home_office> (319)\n<plate> (1002) is INSIDE to <dishwasher> (1001)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\nbowl is ON to dishwasher\ndish_soap is ON to dishwasher\nplate is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "201_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndishwasher, id: 1000, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\ndining_room, id: 201, properties: []\ndish_soap, id: 1002, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\nplate, id: 1001, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<plate> (1001) is INSIDE to <dishwasher> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<dish_soap> (1002) is INSIDE to <dishwasher> (1000)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\nplate is ON to dishwasher\ndish_soap is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "223_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndishwasher, id: 1000, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\ndining_room, id: 201, properties: []\nplate, id: 1002, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nplate, id: 1003, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndish_soap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<dish_soap> (1001) is INSIDE to <dishwasher> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<plate> (1003) is INSIDE to <dishwasher> (1000)\n<plate> (1002) is INSIDE to <dishwasher> (1000)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\ndish_soap is ON to dishwasher\nplate is ON to dishwasher\nplate is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "327_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncoffe_maker, id: 290, properties: ['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\ntoaster, id: 292, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE']\nkitchen_counter, id: 230, properties: ['SURFACES']\ndishwasher, id: 1000, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\nplate, id: 1001, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndish_soap, id: 1002, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\nmicrowave, id: 297, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\nfaucet, id: 232, properties: ['HAS_SWITCH']\ndining_room, id: 201, properties: []\nfood_jam, id: 2011, properties: ['CREAM', 'GRABBABLE', 'EATABLE', 'CAN_OPEN', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<plate> (1001) is NEAR to <kitchen_counter> (230)\n<kitchen_counter> (230) is NEAR to <plate> (1001)\n<plate> (1001) is INSIDE to <dishwasher> (1000)\n<kitchen_counter> (230) is NEAR to <dish_soap> (1002)\n<dish_soap> (1002) is NEAR to <kitchen_counter> (230)\n<plate> (1001) is ON to <kitchen_counter> (230)\n<character> (65) is INSIDE to <home_office> (319)\n<dish_soap> (1002) is INSIDE to <dishwasher> (1000)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\nplate is ON to dishwasher\ndish_soap is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "383_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfood_food, id: 2017, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\ndishwasher, id: 1000, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\nplate, id: 1001, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nplate, id: 1002, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndish_soap, id: 1003, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<plate> (1001) is INSIDE to <dishwasher> (1000)\n<dish_soap> (1003) is INSIDE to <dishwasher> (1000)\n<plate> (1002) is INSIDE to <dishwasher> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<food_food> (2017) is NEAR to <plate> (1002)\n<food_food> (2017) is ON to <plate> (1002)\n<plate> (1002) is NEAR to <food_food> (2017)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\nplate is ON to dishwasher\ndish_soap is ON to dishwasher\nplate is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "417_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndishwasher, id: 1000, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\ndrinking_glass, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndrinking_glass, id: 1002, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nplate, id: 1003, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nfork, id: 1004, properties: ['MOVABLE', 'GRABBABLE']\ndish_soap, id: 1005, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<dish_soap> (1005) is INSIDE to <dishwasher> (1000)\n<drinking_glass> (1001) is INSIDE to <dishwasher> (1000)\n<plate> (1003) is INSIDE to <dishwasher> (1000)\n<fork> (1004) is INSIDE to <dishwasher> (1000)\n<drinking_glass> (1002) is INSIDE to <dishwasher> (1000)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\ndrinking_glass is ON to dishwasher\nfork is ON to dishwasher\nplate is ON to dishwasher\ndrinking_glass is ON to dishwasher\ndish_soap is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "487_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nplate, id: 1000, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndishwasher, id: 1001, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\nfork, id: 1002, properties: ['MOVABLE', 'GRABBABLE']\ncup, id: 1003, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nspoon, id: 1004, properties: ['MOVABLE', 'GRABBABLE']\ndish_soap, id: 1005, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<plate> (1000) is NEAR to <dish_soap> (1005)\n<plate> (1000) is NEAR to <spoon> (1004)\n<dish_soap> (1005) is INSIDE to <dishwasher> (1001)\n<plate> (1000) is NEAR to <fork> (1002)\n<fork> (1002) is INSIDE to <dishwasher> (1001)\n<character> (65) is INSIDE to <bedroom> (67)\n<plate> (1000) is NEAR to <cup> (1003)\n<fork> (1002) is NEAR to <plate> (1000)\n<spoon> (1004) is INSIDE to <dishwasher> (1001)\n<cup> (1003) is NEAR to <plate> (1000)\n<spoon> (1004) is NEAR to <plate> (1000)\n<cup> (1003) is INSIDE to <dishwasher> (1001)\n<dish_soap> (1005) is NEAR to <plate> (1000)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\nspoon is ON to dishwasher\nplate is ON to dishwasher\ncup is ON to dishwasher\ndish_soap is ON to dishwasher\nfork is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "650_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntable, id: 226, properties: ['MOVABLE', 'SURFACES']\nplate, id: 1000, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndishwasher, id: 1001, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\npot, id: 1002, properties: ['CAN_OPEN', 'GRABBABLE', 'MOVABLE', 'RECIPIENT']\ndish_soap, id: 1003, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<pot> (1002) is NEAR to <table> (226)\n<table> (226) is NEAR to <plate> (1000)\n<pot> (1002) is INSIDE to <dishwasher> (1001)\n<character> (65) is INSIDE to <home_office> (319)\n<table> (226) is NEAR to <pot> (1002)\n<plate> (1000) is ON to <table> (226)\n<pot> (1002) is ON to <table> (226)\n<plate> (1000) is NEAR to <table> (226)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\nplate is ON to dishwasher\ndish_soap is ON to dishwasher\npot is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "783_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndishwasher, id: 1000, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\nplate, id: 1001, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nplate, id: 1002, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nplate, id: 1003, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nplate, id: 1004, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nplate, id: 1005, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ncup, id: 1006, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndish_soap, id: 1007, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<plate> (1005) is INSIDE to <dishwasher> (1000)\n<cup> (1006) is INSIDE to <dishwasher> (1000)\n<plate> (1001) is INSIDE to <dishwasher> (1000)\n<plate> (1003) is INSIDE to <dishwasher> (1000)\n<plate> (1004) is INSIDE to <dishwasher> (1000)\n<plate> (1002) is INSIDE to <dishwasher> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<dish_soap> (1007) is INSIDE to <dishwasher> (1000)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\nplate is ON to dishwasher\nplate is ON to dishwasher\nplate is ON to dishwasher\ncup is ON to dishwasher\nplate is ON to dishwasher\nplate is ON to dishwasher\ndish_soap is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "815_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntable, id: 226, properties: ['MOVABLE', 'SURFACES']\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\nplate, id: 1000, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndishwasher, id: 1001, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\ndish_soap, id: 1002, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<table> (226) is NEAR to <plate> (1000)\n<dish_soap> (1002) is INSIDE to <dishwasher> (1001)\n<character> (65) is INSIDE to <bedroom> (67)\n<plate> (1000) is ON to <table> (226)\n<plate> (1000) is NEAR to <table> (226)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\nplate is ON to dishwasher\ndish_soap is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "826_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nbathroom, id: 1, properties: []\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ndishwasher, id: 1000, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\nfork, id: 1001, properties: ['MOVABLE', 'GRABBABLE']\nfork, id: 1002, properties: ['MOVABLE', 'GRABBABLE']\nplate, id: 1003, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nplate, id: 1004, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nplate, id: 1005, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nplate, id: 1006, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ncup, id: 1007, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ncup, id: 1008, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ncup, id: 1009, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ncup, id: 1010, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nknife, id: 1011, properties: ['MOVABLE', 'GRABBABLE']\nknife, id: 1012, properties: ['MOVABLE', 'GRABBABLE']\nspoon, id: 1013, properties: ['MOVABLE', 'GRABBABLE']\nspoon, id: 1014, properties: ['MOVABLE', 'GRABBABLE']\nspoon, id: 1015, properties: ['MOVABLE', 'GRABBABLE']\ndish_soap, id: 1016, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<dish_soap> (1016) is INSIDE to <dishwasher> (1000)\n<spoon> (1013) is INSIDE to <dishwasher> (1000)\n<plate> (1005) is INSIDE to <dishwasher> (1000)\n<spoon> (1015) is INSIDE to <dishwasher> (1000)\n<plate> (1006) is INSIDE to <dishwasher> (1000)\n<cup> (1010) is INSIDE to <dishwasher> (1000)\n<cup> (1009) is INSIDE to <dishwasher> (1000)\n<fork> (1001) is INSIDE to <dishwasher> (1000)\n<plate> (1003) is INSIDE to <dishwasher> (1000)\n<cup> (1008) is INSIDE to <dishwasher> (1000)\n<spoon> (1014) is INSIDE to <dishwasher> (1000)\n<plate> (1004) is INSIDE to <dishwasher> (1000)\n<fork> (1002) is INSIDE to <dishwasher> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<cup> (1007) is INSIDE to <dishwasher> (1000)\n<knife> (1012) is INSIDE to <dishwasher> (1000)\n<knife> (1011) is INSIDE to <dishwasher> (1000)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\nfork is ON to dishwasher\nplate is ON to dishwasher\nplate is ON to dishwasher\nspoon is ON to dishwasher\ncup is ON to dishwasher\nplate is ON to dishwasher\nknife is ON to dishwasher\nspoon is ON to dishwasher\nfork is ON to dishwasher\ncup is ON to dishwasher\ncup is ON to dishwasher\nspoon is ON to dishwasher\ndish_soap is ON to dishwasher\nplate is ON to dishwasher\ncup is ON to dishwasher\nknife is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "856_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndishwasher, id: 1000, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\ndining_room, id: 201, properties: []\ndish_soap, id: 1002, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\nplate, id: 1001, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<plate> (1001) is INSIDE to <dishwasher> (1000)\n<dish_soap> (1002) is INSIDE to <dishwasher> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\nplate is ON to dishwasher\ndish_soap is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "911_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndishwasher, id: 1000, properties: ['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\ncup, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nplate, id: 1002, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndish_soap, id: 1003, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ndishwasher, states: ['OFF', 'CLOSED', 'CLEAN'], properties:['HAS_SWITCH', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<cup> (1001) is INSIDE to <dishwasher> (1000)\n<plate> (1002) is INSIDE to <dishwasher> (1000)\n<dish_soap> (1003) is INSIDE to <dishwasher> (1000)\n-----------------\n\n\nNode goals are:\ndishwasher is CLOSED\ndishwasher is ON\n-----------------\n\n\nEdge goals are:\ncup is ON to dishwasher\ndish_soap is ON to dishwasher\nplate is ON to dishwasher\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1027_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\nbed, id: 105, properties: ['SURFACES', 'LIEABLE', 'SITTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "181_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nbathroom, id: 1, properties: []\nbed, id: 105, properties: ['SURFACES', 'LIEABLE', 'SITTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "244_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\nbed, id: 105, properties: ['SURFACES', 'LIEABLE', 'SITTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "269_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nbathroom, id: 1, properties: []\nbed, id: 105, properties: ['SURFACES', 'LIEABLE', 'SITTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "509_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nclothes_pants, id: 1000, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nclothes_shirt, id: 1002, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nclothes_shirt, id: 1001, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nclothes_pants, id: 1003, properties: ['HANGABLE', 'MOVABLE', 'GRABBABLE', 'CLOTHES']\nsheets, id: 1004, properties: ['MOVABLE', 'GRABBABLE', 'COVER_OBJECT']\nbed, id: 105, properties: ['SURFACES', 'LIEABLE', 'SITTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['ON', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<clothes_pants> (1000) is ON to <character> (65)\n<clothes_pants> (1000) is NEAR to <clothes_shirt> (1002)\n<character> (65) is INSIDE to <dining_room> (201)\n<clothes_shirt> (1001) is ON to <character> (65)\n<clothes_pants> (1000) is NEAR to <clothes_pants> (1003)\n<clothes_shirt> (1002) is NEAR to <clothes_pants> (1000)\n<clothes_pants> (1003) is NEAR to <clothes_pants> (1000)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "875_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfloor, id: 70, properties: ['SURFACES']\nfloor, id: 71, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nfloor, id: 207, properties: ['SURFACES']\nwall, id: 80, properties: []\nwall, id: 82, properties: []\nwindow, id: 86, properties: []\ntablelamp, id: 97, properties: ['HAS_SWITCH']\ntablelamp, id: 98, properties: ['HAS_SWITCH']\nnightstand, id: 100, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\nnightstand, id: 102, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\nbed, id: 105, properties: ['SURFACES', 'LIEABLE', 'SITTABLE']\nmat, id: 173, properties: ['LIEABLE', 'SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndrawing, id: 176, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ncurtain, id: 179, properties: ['MOVABLE', 'CAN_OPEN', 'COVER_OBJECT']\ncurtain, id: 180, properties: ['MOVABLE', 'CAN_OPEN', 'COVER_OBJECT']\ncurtain, id: 181, properties: ['MOVABLE', 'CAN_OPEN', 'COVER_OBJECT']\npillow, id: 182, properties: ['MOVABLE', 'GRABBABLE']\npillow, id: 183, properties: ['MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<wall> (82) is NEAR to <pillow> (182)\n<pillow> (182) is ON to <floor> (207)\n<pillow> (182) is NEAR to <floor> (207)\n<pillow> (182) is NEAR to <nightstand> (100)\n<tablelamp> (98) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <floor> (70)\n<curtain> (180) is NEAR to <pillow> (182)\n<pillow> (183) is NEAR to <pillow> (182)\n<mat> (173) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <floor> (71)\n<pillow> (182) is FACING to <drawing> (176)\n<pillow> (182) is NEAR to <tablelamp> (97)\n<floor> (70) is NEAR to <pillow> (182)\n<character> (65) is INSIDE to <dining_room> (201)\n<pillow> (182) is NEAR to <tablelamp> (98)\n<pillow> (182) is NEAR to <curtain> (179)\n<pillow> (182) is NEAR to <curtain> (181)\n<pillow> (182) is NEAR to <curtain> (180)\n<pillow> (182) is NEAR to <mat> (173)\n<wall> (80) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <wall> (80)\n<curtain> (179) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <pillow> (183)\n<pillow> (182) is NEAR to <window> (86)\n<floor> (207) is NEAR to <pillow> (182)\n<nightstand> (102) is NEAR to <pillow> (182)\n<window> (86) is NEAR to <pillow> (182)\n<tablelamp> (97) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <nightstand> (102)\n<floor> (71) is NEAR to <pillow> (182)\n<curtain> (181) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <wall> (82)\n<nightstand> (100) is NEAR to <pillow> (182)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "102_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhands_both, id: 1000, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "154_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntowel, id: 1002, properties: ['MOVABLE', 'GRABBABLE', 'COVER_OBJECT']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nhands_both, id: 1003, properties: ['BODY_PART']\nhands_both, id: 1001, properties: ['BODY_PART']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<towel> (1002) is NEAR to <sink> (42)\n<soap> (1000) is NEAR to <sink> (42)\n<sink> (42) is NEAR to <soap> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n<sink> (42) is NEAR to <towel> (1002)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "176_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "214_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "258_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\nfaucet, id: 232, properties: ['HAS_SWITCH']\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfaucet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\n\nEdges:\n<soap> (1000) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <soap> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "499_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater, id: 1000, properties: ['DRINKABLE', 'POURABLE']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\npaper_towel, id: 1003, properties: ['HAS_PAPER', 'GRABBABLE', 'COVER_OBJECT', 'MOVABLE', 'HANGABLE', 'CUTTABLE']\nhands_both, id: 1002, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (42) is NEAR to <paper_towel> (1003)\n<paper_towel> (1003) is NEAR to <sink> (42)\n<character> (65) is INSIDE to <home_office> (319)\n<sink> (42) is NEAR to <soap> (1001)\n<soap> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "517_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<soap> (1000) is ON to <sink> (42)\n<soap> (1000) is NEAR to <sink> (42)\n<character> (65) is INSIDE to <home_office> (319)\n<sink> (42) is NEAR to <soap> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "549_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nhands_both, id: 1000, properties: ['BODY_PART']\ncharacter, id: 65, properties: []\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "562_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater, id: 1000, properties: ['DRINKABLE', 'POURABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<faucet> (43) is NEAR to <water> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<water> (1000) is NEAR to <faucet> (43)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nwater is INSIDE to hands_both\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "580_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nhands_both, id: 1000, properties: ['BODY_PART']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ntowel, id: 1002, properties: ['MOVABLE', 'GRABBABLE', 'COVER_OBJECT']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<towel> (1002) is NEAR to <sink> (42)\n<character> (65) is INSIDE to <bedroom> (67)\n<sink> (42) is NEAR to <soap> (1001)\n<sink> (42) is NEAR to <towel> (1002)\n<soap> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "657_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhands_both, id: 1000, properties: ['BODY_PART']\ndining_room, id: 201, properties: []\ntowel, id: 1002, properties: ['MOVABLE', 'GRABBABLE', 'COVER_OBJECT']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<faucet> (43) is NEAR to <towel> (1002)\n<towel> (1002) is NEAR to <faucet> (43)\n<character> (65) is INSIDE to <dining_room> (201)\n<faucet> (43) is NEAR to <soap> (1001)\n<soap> (1001) is NEAR to <faucet> (43)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "660_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "672_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhands_both, id: 1000, properties: ['BODY_PART']\ndining_room, id: 201, properties: []\ntowel, id: 1002, properties: ['MOVABLE', 'GRABBABLE', 'COVER_OBJECT']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<faucet> (43) is NEAR to <towel> (1002)\n<towel> (1002) is NEAR to <faucet> (43)\n<character> (65) is INSIDE to <dining_room> (201)\n<faucet> (43) is NEAR to <soap> (1001)\n<soap> (1001) is NEAR to <faucet> (43)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "710_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater, id: 1000, properties: ['DRINKABLE', 'POURABLE']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nhands_both, id: 1002, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n<sink> (42) is NEAR to <soap> (1001)\n<soap> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "741_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nfaucet, id: 43, properties: ['HAS_SWITCH']\nhands_both, id: 1001, properties: ['BODY_PART']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<faucet> (43) is NEAR to <soap> (1000)\n<soap> (1000) is NEAR to <faucet> (43)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "750_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\ntowel, id: 1003, properties: ['MOVABLE', 'GRABBABLE', 'COVER_OBJECT']\nhands_both, id: 1002, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (42) is NEAR to <towel> (1003)\n<towel> (1003) is NEAR to <sink> (42)\n<character> (65) is INSIDE to <bedroom> (67)\n<sink> (42) is NEAR to <water> (1001)\n<water> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nwater is INSIDE to hands_both\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "805_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\ntowel, id: 1001, properties: ['MOVABLE', 'GRABBABLE', 'COVER_OBJECT']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<soap> (1000) is NEAR to <sink> (42)\n<sink> (42) is NEAR to <soap> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n<sink> (42) is NEAR to <towel> (1001)\n<towel> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "80_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nbathroom_counter, id: 41, properties: ['SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "813_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater, id: 1000, properties: ['DRINKABLE', 'POURABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "928_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhands_both, id: 1000, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "995_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nfaucet, id: 43, properties: ['HAS_SWITCH']\nhands_both, id: 1001, properties: ['BODY_PART']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1035_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "113_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "12_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "137_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "203_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\nhair, id: 2014, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "220_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "242_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "279_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "287_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "292_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhair, id: 2006, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "297_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "381_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "388_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "38_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nface, id: 1001, properties: ['BODY_PART']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "429_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "437_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhair, id: 2013, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "451_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "469_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "479_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "502_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "612_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "856_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "384_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nwalllamp, id: 351, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <cpuscreen> (416)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<keyboard> (415) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (326)\n<chair> (356) is NEAR to <mouse> (413)\n<wall> (213) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <floor> (326)\n<mouse> (413) is NEAR to <wall> (213)\n<keyboard> (415) is NEAR to <computer> (417)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<keyboard> (415) is NEAR to <walllamp> (351)\n<mouse> (413) is NEAR to <chair> (356)\n<floor> (325) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <floor> (208)\n<computer> (417) is NEAR to <keyboard> (415)\n<chair> (356) is NEAR to <keyboard> (415)\n<floor> (326) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <wall> (331)\n<keyboard> (415) is NEAR to <wall> (330)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n<keyboard> (415) is ON to <desk> (357)\n<mouse> (413) is NEAR to <floor> (325)\n<keyboard> (415) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<wall> (331) is NEAR to <keyboard> (415)\n<floor> (326) is NEAR to <keyboard> (415)\n<walllamp> (351) is NEAR to <keyboard> (415)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<character> (65) is INSIDE to <bathroom> (1)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <wall> (213)\n<mousepad> (414) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<cpuscreen> (416) is NEAR to <keyboard> (415)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <desk> (357)\n<wall> (330) is NEAR to <keyboard> (415)\n<desk> (357) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<wall> (213) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <wall> (330)\n<keyboard> (415) is NEAR to <floor> (325)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to computer\ncharacter is HOLDS_LH to keyboard\ncharacter is INSIDE to home_office\ncharacter is HOLDS_RH to mouse\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "540_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to phone\ncharacter is FACING to phone\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "60_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nwall, id: 213, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nwalllamp, id: 351, properties: []\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nlaptop, id: 1000, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlaptop, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<laptop> (1000) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <cpuscreen> (416)\n<keyboard> (415) is NEAR to <chair> (356)\n<keyboard> (415) is NEAR to <floor> (326)\n<keyboard> (415) is NEAR to <computer> (417)\n<keyboard> (415) is NEAR to <walllamp> (351)\n<keyboard> (415) is NEAR to <laptop> (1000)\n<floor> (325) is NEAR to <keyboard> (415)\n<computer> (417) is NEAR to <keyboard> (415)\n<chair> (356) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <wall> (331)\n<character> (65) is INSIDE to <dining_room> (201)\n<keyboard> (415) is NEAR to <wall> (330)\n<keyboard> (415) is ON to <desk> (357)\n<keyboard> (415) is NEAR to <mousepad> (414)\n<wall> (331) is NEAR to <keyboard> (415)\n<floor> (326) is NEAR to <keyboard> (415)\n<walllamp> (351) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <wall> (213)\n<mousepad> (414) is NEAR to <keyboard> (415)\n<cpuscreen> (416) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <desk> (357)\n<wall> (330) is NEAR to <keyboard> (415)\n<desk> (357) is NEAR to <keyboard> (415)\n<wall> (213) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <floor> (325)\n-----------------\n\n\nNode goals are:\nlaptop is ON\nlaptop is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to laptop\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "71_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nwalllamp, id: 351, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <cpuscreen> (416)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<keyboard> (415) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (326)\n<chair> (356) is NEAR to <mouse> (413)\n<wall> (213) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <floor> (326)\n<mouse> (413) is NEAR to <wall> (213)\n<keyboard> (415) is NEAR to <computer> (417)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<keyboard> (415) is NEAR to <walllamp> (351)\n<mouse> (413) is NEAR to <chair> (356)\n<floor> (325) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <floor> (208)\n<computer> (417) is NEAR to <keyboard> (415)\n<chair> (356) is NEAR to <keyboard> (415)\n<floor> (326) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <wall> (331)\n<keyboard> (415) is NEAR to <wall> (330)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n<keyboard> (415) is ON to <desk> (357)\n<mouse> (413) is NEAR to <floor> (325)\n<keyboard> (415) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<wall> (331) is NEAR to <keyboard> (415)\n<floor> (326) is NEAR to <keyboard> (415)\n<walllamp> (351) is NEAR to <keyboard> (415)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<character> (65) is INSIDE to <bedroom> (67)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <wall> (213)\n<mousepad> (414) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<cpuscreen> (416) is NEAR to <keyboard> (415)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <desk> (357)\n<wall> (330) is NEAR to <keyboard> (415)\n<desk> (357) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<wall> (213) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <wall> (330)\n<keyboard> (415) is NEAR to <floor> (325)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to computer\ncharacter is HOLDS_LH to keyboard\ncharacter is HOLDS_RH to mouse\ncharacter is INSIDE to home_office\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "7_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'LOOKABLE']\n\nEdges:\n<mouse> (413) is NEAR to <mousepad> (414)\n<desk> (357) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <wall> (213)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <floor> (208)\n<floor> (326) is NEAR to <mouse> (413)\n<character> (65) is INSIDE to <dining_room> (201)\n<mouse> (413) is ON to <mousepad> (414)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <powersocket> (412)\n<powersocket> (412) is NEAR to <mouse> (413)\n<floor> (325) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<mouse> (413) is NEAR to <wall> (331)\n<mouse> (413) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<wall> (331) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <mouse> (413)\n<floor> (208) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<mouse> (413) is NEAR to <wall> (330)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to computer\ncharacter is HOLDS_RH to mouse\ncharacter is INSIDE to home_office\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1070_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntoothbrush_holder, id: 1000, properties: ['CONTAINERS', 'MOVABLE', 'GRABBABLE']\ntoothbrush, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT']\ntooth_paste, id: 1002, properties: ['CREAM', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE', 'POURABLE']\nteeth, id: 1003, properties: ['MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<toothbrush_holder> (1000) is NEAR to <toothbrush> (1001)\n<character> (65) is INSIDE to <home_office> (319)\n<toothbrush> (1001) is NEAR to <toothbrush_holder> (1000)\n<toothbrush> (1001) is ON to <toothbrush_holder> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to toothbrush\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "313_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntooth_paste, id: 1000, properties: ['CREAM', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE', 'POURABLE']\ndining_room, id: 201, properties: []\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\ntowel, id: 1003, properties: ['MOVABLE', 'GRABBABLE', 'COVER_OBJECT']\ntoothbrush, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT']\nteeth, id: 1002, properties: ['MOVABLE', 'GRABBABLE']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (42) is NEAR to <towel> (1003)\n<tooth_paste> (1000) is NEAR to <sink> (42)\n<sink> (42) is NEAR to <tooth_paste> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n<towel> (1003) is NEAR to <sink> (42)\n<sink> (42) is NEAR to <toothbrush> (1001)\n<tooth_paste> (1000) is ON to <sink> (42)\n<toothbrush> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to toothbrush\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "689_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\ntoothbrush_holder, id: 1000, properties: ['CONTAINERS', 'MOVABLE', 'GRABBABLE']\ntooth_paste, id: 1001, properties: ['CREAM', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE', 'POURABLE']\ntoothbrush, id: 1002, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<toothbrush_holder> (1000) is NEAR to <toothbrush> (1002)\n<character> (65) is INSIDE to <bedroom> (67)\n<tooth_paste> (1001) is ON to <toothbrush_holder> (1000)\n<toothbrush> (1002) is NEAR to <toothbrush_holder> (1000)\n<toothbrush_holder> (1000) is NEAR to <tooth_paste> (1001)\n<tooth_paste> (1001) is NEAR to <toothbrush_holder> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to toothbrush\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "718_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\ntooth_paste, id: 1000, properties: ['CREAM', 'GRABBABLE', 'CAN_OPEN', 'MOVABLE', 'POURABLE']\ntoothbrush, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<tooth_paste> (1000) is NEAR to <toothbrush> (1001)\n<toothbrush> (1001) is NEAR to <tooth_paste> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to toothbrush\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1049_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndvd_player, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ndvd_player, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ndvd_player is CLOSED\ndvd_player is ON\ndvd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "113_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncd_player, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncd_player, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncd_player is CLOSED\ncd_player is ON\ncd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "161_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "173_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ncd_player, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\nheadset, id: 1001, properties: ['MOVABLE', 'GRABBABLE', 'CLOTHES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncd_player, states: ['OFF', 'CLOSED', 'PLUGGED_OUT', 'CLEAN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, states: ['SITTING'], properties:[]\n\nEdges:\n<cd_player> (1000) is NEAR to <headset> (1001)\n<character> (65) is INSIDE to <home_office> (319)\n<headset> (1001) is NEAR to <cd_player> (1000)\n-----------------\n\n\nNode goals are:\ncd_player is CLOSED\ncd_player is ON\ncd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "23_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "263_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "305_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nmouse, id: 166, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 167, properties: ['MOVABLE', 'SURFACES']\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndesk, id: 104, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 168, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nchair, id: 103, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ncpuscreen, id: 171, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nstereo, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "363_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nmusic_stand, id: 1000, properties: ['CAN_OPEN', 'CONTAINERS', 'MOVABLE', 'SURFACES']\ndvd_player, id: 1001, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\nremote_control, id: 1002, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ndvd_player, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n<music_stand> (1000) is NEAR to <remote_control> (1002)\n<remote_control> (1002) is NEAR to <music_stand> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ndvd_player is CLOSED\ndvd_player is ON\ndvd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "385_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncd_player, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncd_player, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncd_player is CLOSED\ncd_player is ON\ncd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "403_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhair, id: 2004, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "415_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nheadset, id: 1000, properties: ['MOVABLE', 'GRABBABLE', 'CLOTHES']\ncharacter, id: 65, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nheadset is ON to character\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "462_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nchair, id: 103, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\nheadset, id: 1001, properties: ['MOVABLE', 'GRABBABLE', 'CLOTHES']\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, states: [], properties:[]\n\nEdges:\n<stereo> (1000) is NEAR to <headset> (1001)\n<character> (65) is INSIDE to <bathroom> (1)\n<headset> (1001) is NEAR to <stereo> (1000)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "463_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "503_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncd_player, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\nremote_control, id: 1001, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nchair, id: 103, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncd_player, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, states: [], properties:[]\n\nEdges:\n-----------------\n\n\nNode goals are:\ncd_player is CLOSED\ncd_player is ON\ncd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "59_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nheadset, id: 1001, properties: ['MOVABLE', 'GRABBABLE', 'CLOTHES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<phone> (1000) is NEAR to <headset> (1001)\n<headset> (1001) is NEAR to <phone> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nheadset is ON to character\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "737_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "773_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "910_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "953_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nmusic_stand, id: 1000, properties: ['CAN_OPEN', 'CONTAINERS', 'MOVABLE', 'SURFACES']\ncd_player, id: 1001, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncd_player, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncd_player is CLOSED\ncd_player is ON\ncd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1057_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nhair, id: 2001, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nbedroom, id: 67, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "117_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <bathroom> (1)\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "134_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'PLUGGED_OUT', 'CLEAN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <bathroom> (1)\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "170_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "197_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nelectrical_outlet, id: 1001, properties: ['HAS_SWITCH']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nelectrical_outlet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <electrical_outlet> (1001)\n<remote_control> (1000) is NEAR to <chair> (356)\n<character> (65) is INSIDE to <bedroom> (67)\n<chair> (356) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n<electrical_outlet> (1001) is NEAR to <remote_control> (1000)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "21_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ntable, id: 355, properties: ['MOVABLE', 'SURFACES']\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<remote_control> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <remote_control> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "225_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ncoffee_table, id: 1000, properties: ['MOVABLE', 'SURFACES']\nremote_control, id: 1001, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<couch> (352) is NEAR to <remote_control> (1001)\n<remote_control> (1001) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <bedroom> (67)\n<remote_control> (1001) is ON to <coffee_table> (1000)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "259_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<remote_control> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <remote_control> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "307_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "329_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "342_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "377_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "383_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "411_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n<remote_control> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <remote_control> (1000)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "454_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<remote_control> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <remote_control> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "459_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "548_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ntelevision, id: 248, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "595_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncoffee_table, id: 1001, properties: ['MOVABLE', 'SURFACES']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<remote_control> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <remote_control> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "684_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "74_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <bathroom> (1)\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "806_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<remote_control> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <remote_control> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "98_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <bedroom> (67)\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1064_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nwater_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "156_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfaucet, id: 232, properties: ['HAS_SWITCH']\ncharacter, id: 65, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\ncup, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<cup> (1000) is NEAR to <sink> (231)\n<cup> (1000) is NEAR to <faucet> (232)\n<sink> (231) is NEAR to <cup> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<faucet> (232) is NEAR to <cup> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "171_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\ncup, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\nfaucet, id: 232, properties: ['HAS_SWITCH']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncupboard, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<cup> (1000) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <cup> (1000)\n<cup> (1000) is INSIDE to <cupboard> (229)\n<character> (65) is INSIDE to <bathroom> (1)\n<cup> (1000) is NEAR to <cupboard> (229)\n<cupboard> (229) is NEAR to <cup> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "175_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfaucet, id: 232, properties: ['HAS_SWITCH']\ncharacter, id: 65, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\ncup, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<cup> (1000) is NEAR to <sink> (231)\n<character> (65) is INSIDE to <home_office> (319)\n<sink> (231) is NEAR to <cup> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "181_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nbathroom, id: 1, properties: []\ncharacter, id: 65, properties: []\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ndining_room, id: 201, properties: []\nwater_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<water> (1001) is INSIDE to <freezer> (289)\n<freezer> (289) is NEAR to <water_glass> (1000)\n<water> (1001) is NEAR to <freezer> (289)\n<character> (65) is INSIDE to <bathroom> (1)\n<freezer> (289) is NEAR to <water> (1001)\n<water_glass> (1000) is NEAR to <freezer> (289)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "26_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nfaucet, id: 232, properties: ['HAS_SWITCH']\ncup, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nhair, id: 2009, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<cup> (1000) is NEAR to <faucet> (232)\n<faucet> (232) is NEAR to <cup> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "286_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nwater_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncupboard, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<water> (1001) is INSIDE to <freezer> (289)\n<water_glass> (1000) is INSIDE to <cupboard> (229)\n<character> (65) is INSIDE to <bathroom> (1)\n<water_glass> (1000) is NEAR to <cupboard> (229)\n<cupboard> (229) is NEAR to <water_glass> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "291_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater, id: 1000, properties: ['DRINKABLE', 'POURABLE']\nwater_glass, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<water> (1000) is NEAR to <water_glass> (1001)\n<water_glass> (1001) is INSIDE to <dining_room> (201)\n<character> (65) is INSIDE to <bathroom> (1)\n<water_glass> (1001) is NEAR to <water> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "317_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nbathroom, id: 1, properties: []\ncharacter, id: 65, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\ncup, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nfaucet, id: 232, properties: ['HAS_SWITCH']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nkitchen_cabinet, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN', 'SURFACES']\n\nEdges:\n<sink> (231) is NEAR to <cup> (1001)\n<cup> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<cup> (1001) is NEAR to <sink> (231)\n<character> (65) is INSIDE to <bathroom> (1)\n<kitchen_cabinet> (1000) is NEAR to <cup> (1001)\n<cup> (1001) is NEAR to <kitchen_cabinet> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "488_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\ncup, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n<water> (1001) is ON to <sink> (231)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "510_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nwater, id: 1000, properties: ['DRINKABLE', 'POURABLE']\ndrinking_glass, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<water> (1000) is NEAR to <drinking_glass> (1001)\n<character> (65) is INSIDE to <home_office> (319)\n<drinking_glass> (1001) is NEAR to <water> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to drinking_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "528_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncharacter, id: 65, properties: []\ndrinking_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<drinking_glass> (1000) is INSIDE to <freezer> (289)\n<character> (65) is INSIDE to <home_office> (319)\n<drinking_glass> (1000) is NEAR to <freezer> (289)\n<freezer> (289) is NEAR to <drinking_glass> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to drinking_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "532_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nbathroom, id: 1, properties: []\ncharacter, id: 65, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\ndrinking_glass, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nwater, id: 1002, properties: ['DRINKABLE', 'POURABLE']\nfaucet, id: 232, properties: ['HAS_SWITCH']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (231) is NEAR to <drinking_glass> (1001)\n<drinking_glass> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<drinking_glass> (1001) is NEAR to <sink> (231)\n<character> (65) is INSIDE to <bathroom> (1)\n<kitchen_cabinet> (1000) is NEAR to <drinking_glass> (1001)\n<drinking_glass> (1001) is NEAR to <kitchen_cabinet> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to drinking_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "589_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ncup, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "600_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<water_glass> (1000) is INSIDE to <freezer> (289)\n<character> (65) is INSIDE to <bathroom> (1)\n<water_glass> (1000) is NEAR to <freezer> (289)\n<freezer> (289) is NEAR to <water_glass> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "662_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nwater_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "688_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\nwater_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\nfaucet, id: 232, properties: ['HAS_SWITCH']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<water_glass> (1000) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <water_glass> (1000)\n<water_glass> (1000) is INSIDE to <cupboard> (229)\n<character> (65) is INSIDE to <home_office> (319)\n<water_glass> (1000) is NEAR to <cupboard> (229)\n<cupboard> (229) is NEAR to <water_glass> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\ncharacter is HOLDS_LH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "787_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nbathroom, id: 1, properties: []\ncharacter, id: 65, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\nwater_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nfaucet, id: 232, properties: ['HAS_SWITCH']\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<water_glass> (1000) is NEAR to <sink> (231)\n<water_glass> (1000) is NEAR to <faucet> (232)\n<sink> (231) is NEAR to <water_glass> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<water_glass> (1000) is NEAR to <water> (1001)\n<faucet> (232) is NEAR to <water_glass> (1000)\n<water> (1001) is NEAR to <water_glass> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "788_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\nfaucet, id: 232, properties: ['HAS_SWITCH']\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\ndrinking_glass, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nwater, id: 1002, properties: ['DRINKABLE', 'POURABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfaucet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\nkitchen_cabinet, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN', 'SURFACES']\n\nEdges:\n<sink> (231) is NEAR to <drinking_glass> (1001)\n<drinking_glass> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<drinking_glass> (1001) is NEAR to <sink> (231)\n<character> (65) is INSIDE to <bathroom> (1)\n<kitchen_cabinet> (1000) is NEAR to <drinking_glass> (1001)\n<drinking_glass> (1001) is NEAR to <kitchen_cabinet> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to drinking_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "814_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nwater_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncupboard, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<water> (1001) is INSIDE to <cupboard> (229)\n<water_glass> (1000) is INSIDE to <cupboard> (229)\n<character> (65) is INSIDE to <home_office> (319)\n<water_glass> (1000) is NEAR to <cupboard> (229)\n<cupboard> (229) is NEAR to <water_glass> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "850_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nfaucet, id: 232, properties: ['HAS_SWITCH']\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\nwater_glass, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfaucet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\nkitchen_cabinet, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN', 'SURFACES']\n\nEdges:\n<kitchen_cabinet> (1000) is NEAR to <water_glass> (1001)\n<water_glass> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<water_glass> (1001) is NEAR to <kitchen_cabinet> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "861_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\ncup, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\nfaucet, id: 232, properties: ['HAS_SWITCH']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<cup> (1000) is NEAR to <sink> (231)\n<cup> (1000) is ON to <sink> (231)\n<sink> (231) is NEAR to <cup> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "878_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nwater_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncupboard, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<water> (1001) is INSIDE to <cupboard> (229)\n<water_glass> (1000) is INSIDE to <cupboard> (229)\n<character> (65) is INSIDE to <home_office> (319)\n<water_glass> (1000) is NEAR to <cupboard> (229)\n<cupboard> (229) is NEAR to <water_glass> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1073_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ndining_room, id: 201, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<novel> (1000) is NEAR to <light> (411)\n<character> (65) is INSIDE to <dining_room> (201)\n<light> (411) is NEAR to <novel> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1088_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ncharacter, id: 65, properties: []\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\nfiling_cabinet, id: 399, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<filing_cabinet> (399) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <filing_cabinet> (399)\n<novel> (1000) is ON to <filing_cabinet> (399)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "15_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\naddress_book, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to address_book\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "163_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<chair> (356) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<novel> (1000) is NEAR to <chair> (356)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "16_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ndining_room, id: 201, properties: []\ncoffee_table, id: 1001, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<novel> (1000) is NEAR to <coffee_table> (1001)\n<novel> (1000) is ON to <coffee_table> (1001)\n<coffee_table> (1001) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "192_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ncharacter, id: 65, properties: []\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<novel> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <novel> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "208_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhair, id: 2006, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\nnovel, id: 1001, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<floor_lamp> (1000) is NEAR to <novel> (1001)\n<character> (65) is INSIDE to <home_office> (319)\n<novel> (1001) is NEAR to <floor_lamp> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "221_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nnovel, id: 1001, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "241_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "341_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nplate, id: 1000, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nnovel, id: 1001, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ncoffee_table, id: 1002, properties: ['MOVABLE', 'SURFACES']\nspectacles, id: 1003, properties: ['MOVABLE', 'GRABBABLE', 'CLOTHES']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncupboard, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<spectacles> (1003) is NEAR to <novel> (1001)\n<spectacles> (1003) is NEAR to <couch> (352)\n<novel> (1001) is NEAR to <coffee_table> (1002)\n<couch> (352) is NEAR to <novel> (1001)\n<character> (65) is INSIDE to <dining_room> (201)\n<novel> (1001) is INSIDE to <cupboard> (229)\n<novel> (1001) is NEAR to <couch> (352)\n<novel> (1001) is NEAR to <spectacles> (1003)\n<coffee_table> (1002) is NEAR to <novel> (1001)\n<spectacles> (1003) is INSIDE to <cupboard> (229)\n<couch> (352) is NEAR to <spectacles> (1003)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to spectacles\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "484_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['HAS_SWITCH', 'LOOKABLE']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<chair> (356) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <chair> (356)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "504_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "508_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "544_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "57_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n<novel> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <novel> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "617_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntablelamp, id: 97, properties: ['HAS_SWITCH']\nbedroom, id: 67, properties: []\nnightstand, id: 100, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nbed, id: 105, properties: ['SURFACES', 'LIEABLE', 'SITTABLE']\ndrawing, id: 176, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nnightstand, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN', 'SURFACES']\n\nEdges:\n<novel> (1000) is INSIDE to <nightstand> (100)\n<character> (65) is INSIDE to <home_office> (319)\n<novel> (1000) is NEAR to <nightstand> (100)\n<nightstand> (100) is NEAR to <novel> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "628_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n<novel> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <novel> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "688_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nspectacles, id: 1001, properties: ['MOVABLE', 'GRABBABLE', 'CLOTHES']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['OFF', 'PLUGGED_OUT', 'CLEAN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<novel> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <bedroom> (67)\n<novel> (1000) is NEAR to <light> (411)\n<couch> (352) is NEAR to <novel> (1000)\n<light> (411) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <spectacles> (1001)\n<spectacles> (1001) is NEAR to <novel> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "693_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nchair, id: 103, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<novel> (1000) is NEAR to <chair> (103)\n<chair> (103) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "821_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<chair> (356) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<novel> (1000) is NEAR to <chair> (356)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "86_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nfiling_cabinet, id: 399, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<filing_cabinet> (399) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <filing_cabinet> (399)\n<character> (65) is INSIDE to <bathroom> (1)\n<novel> (1000) is ON to <filing_cabinet> (399)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "896_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ncpuscreen, id: 416, properties: []\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nbookmark, id: 1001, properties: ['HAS_PAPER', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<novel> (1000) is NEAR to <couch> (352)\n<desk> (357) is NEAR to <novel> (1000)\n<novel> (1000) is ON to <desk> (357)\n<bookmark> (1001) is NEAR to <desk> (357)\n<couch> (352) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <desk> (357)\n<desk> (357) is NEAR to <bookmark> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "897_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntable, id: 355, properties: ['MOVABLE', 'SURFACES']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nnovel, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\ndining_room, id: 201, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<novel> (1000) is NEAR to <light> (411)\n<character> (65) is INSIDE to <dining_room> (201)\n<light> (411) is NEAR to <novel> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "1083_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\noven, id: 295, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\npot, id: 1000, properties: ['CAN_OPEN', 'GRABBABLE', 'MOVABLE', 'RECIPIENT']\nfood_vegetable, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nwater, id: 1002, properties: ['DRINKABLE', 'POURABLE']\npot, id: 1003, properties: ['CAN_OPEN', 'GRABBABLE', 'MOVABLE', 'RECIPIENT']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\noven, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<water> (1002) is NEAR to <oven> (295)\n<oven> (295) is NEAR to <water> (1002)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\noven is CLOSED\noven is ON\noven is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\npot is ON to oven\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "392_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfreezer, id: 289, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\npot, id: 1001, properties: ['CAN_OPEN', 'GRABBABLE', 'MOVABLE', 'RECIPIENT']\noven, id: 295, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\noven, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<pot> (1001) is NEAR to <freezer> (289)\n<freezer> (289) is NEAR to <pot> (1001)\n<pot> (1001) is INSIDE to <freezer> (289)\n-----------------\n\n\nNode goals are:\noven is CLOSED\noven is ON\noven is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\npot is ON to oven\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "755_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\noven, id: 295, properties: ['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\ndining_room, id: 201, properties: []\nwater, id: 1002, properties: ['DRINKABLE', 'POURABLE']\nsauce_pan, id: 1003, properties: ['CONTAINERS', 'SURFACES', 'GRABBABLE', 'MOVABLE', 'RECIPIENT']\npasta, id: 1001, properties: ['MOVABLE', 'GRABBABLE', 'POURABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nkitchen_cabinet, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN', 'SURFACES']\noven, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<kitchen_cabinet> (1000) is NEAR to <water> (1002)\n<pasta> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<sauce_pan> (1003) is INSIDE to <kitchen_cabinet> (1000)\n<kitchen_cabinet> (1000) is NEAR to <sauce_pan> (1003)\n<character> (65) is INSIDE to <home_office> (319)\n<water> (1002) is INSIDE to <kitchen_cabinet> (1000)\n<water> (1002) is NEAR to <kitchen_cabinet> (1000)\n<sauce_pan> (1003) is NEAR to <kitchen_cabinet> (1000)\n<kitchen_cabinet> (1000) is NEAR to <pasta> (1001)\n<pasta> (1001) is NEAR to <kitchen_cabinet> (1000)\n-----------------\n\n\nNode goals are:\noven is CLOSED\noven is ON\noven is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nsauce_pan is ON to oven\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "124_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhair, id: 2006, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "137_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "204_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ncoffee, id: 1000, properties: ['DRINKABLE', 'MOVABLE', 'GRABBABLE', 'POURABLE']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<television> (410) is NEAR to <coffee> (1000)\n<coffee> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <bedroom> (67)\n<couch> (352) is NEAR to <coffee> (1000)\n<coffee> (1000) is NEAR to <television> (410)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "268_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "297_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 322, properties: ['SURFACES']\nfloor, id: 323, properties: ['SURFACES']\nbedroom, id: 67, properties: []\nwall, id: 329, properties: []\nwall, id: 333, properties: []\ndrawing, id: 400, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nmat, id: 401, properties: ['LIEABLE', 'SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\npillow, id: 405, properties: ['MOVABLE', 'GRABBABLE']\ncurtain, id: 409, properties: ['MOVABLE', 'CAN_OPEN', 'COVER_OBJECT']\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nwindow, id: 348, properties: []\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\nchair, id: 356, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['ON', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\ncharacter, states: [], properties:[]\n\nEdges:\n<floor> (322) is NEAR to <pillow> (405)\n<pillow> (405) is NEAR to <curtain> (409)\n<pillow> (405) is NEAR to <window> (348)\n<pillow> (405) is NEAR to <mat> (401)\n<pillow> (405) is FACING to <television> (410)\n<drawing> (400) is NEAR to <pillow> (405)\n<window> (348) is NEAR to <pillow> (405)\n<pillow> (405) is NEAR to <wall> (329)\n<pillow> (405) is NEAR to <wall> (333)\n<wall> (333) is NEAR to <pillow> (405)\n<chair> (356) is NEAR to <pillow> (405)\n<pillow> (405) is NEAR to <floor> (322)\n<pillow> (405) is NEAR to <floor> (323)\n<wall> (329) is NEAR to <pillow> (405)\n<floor> (323) is NEAR to <pillow> (405)\n<character> (65) is INSIDE to <bedroom> (67)\n<pillow> (405) is NEAR to <drawing> (400)\n<mat> (401) is NEAR to <pillow> (405)\n<pillow> (405) is NEAR to <chair> (356)\n<curtain> (409) is NEAR to <pillow> (405)\n<pillow> (405) is FACING to <drawing> (400)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "299_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "300_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "321_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nwater_glass, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<water_glass> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <water_glass> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "332_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "379_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "387_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "390_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "3_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "416_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "438_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "442_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "447_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ncoffee_cup, id: 1000, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\nnovel, id: 1001, properties: ['READABLE', 'HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'CAN_OPEN', 'CUTTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<coffee_cup> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <novel> (1001)\n<character> (65) is INSIDE to <dining_room> (201)\n<couch> (352) is NEAR to <coffee_cup> (1000)\n<novel> (1001) is NEAR to <couch> (352)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "449_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<remote_control> (1000) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <remote_control> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "455_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "456_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "473_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nsheets, id: 1000, properties: ['MOVABLE', 'GRABBABLE', 'COVER_OBJECT']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "490_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "563_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "567_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nstereo, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['OFF', 'CLOSED', 'PLUGGED_OUT', 'CLEAN'], properties:['SURFACES', 'GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH']\ncharacter, states: [], properties:[]\nlight, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "570_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "674_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "6_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "742_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "762_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "793_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "798_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "932_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "941_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "96_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "976_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "149_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ntable, id: 355, properties: ['MOVABLE', 'SURFACES']\nfood_food, id: 2003, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\n\nEdges:\n<table> (355) is NEAR to <phone> (1000)\n<phone> (1000) is ON to <table> (355)\n<phone> (1000) is NEAR to <table> (355)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "154_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nbutton, id: 1001, properties: ['MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<phone> (1000) is NEAR to <button> (1001)\n<button> (1001) is NEAR to <phone> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "180_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nhair, id: 2005, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['MOVABLE', 'CONTAINERS', 'CAN_OPEN']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nwall_clock, id: 249, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\nphone, states: ['OFF', 'PLUGGED_OUT', 'CLEAN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<drawing> (240) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (216)\n<wall> (84) is NEAR to <phone> (247)\n<drawing> (174) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall_clock> (249)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <door> (222)\n<doorjamb> (165) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <drawing> (240)\n<trashcan> (99) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <drawing> (174)\n<ceiling> (217) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (245)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <floor> (202)\n<floor> (203) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (238)\n<light> (245) is NEAR to <phone> (247)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n<door> (222) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <ceiling> (217)\n<phone> (247) is NEAR to <trashcan> (99)\n<phone> (247) is NEAR to <ceiling> (94)\n<phone> (247) is NEAR to <wall> (209)\n<floor> (206) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<floor> (77) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <drawing> (239)\n<phone> (247) is NEAR to <wall> (211)\n<phone> (247) is NEAR to <ceiling> (95)\n<powersocket> (246) is NEAR to <phone> (247)\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (206)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "195_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\ntable, id: 355, properties: ['MOVABLE', 'SURFACES']\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<table> (355) is NEAR to <phone> (1000)\n<phone> (1000) is ON to <table> (355)\n<phone> (1000) is NEAR to <table> (355)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "211_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['MOVABLE', 'CONTAINERS', 'CAN_OPEN']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nwall_clock, id: 249, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<drawing> (240) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (216)\n<wall> (84) is NEAR to <phone> (247)\n<drawing> (174) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall_clock> (249)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <door> (222)\n<doorjamb> (165) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <drawing> (240)\n<trashcan> (99) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <drawing> (174)\n<ceiling> (217) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (245)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <floor> (202)\n<floor> (203) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (238)\n<light> (245) is NEAR to <phone> (247)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n<door> (222) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <ceiling> (217)\n<phone> (247) is NEAR to <trashcan> (99)\n<phone> (247) is NEAR to <ceiling> (94)\n<phone> (247) is NEAR to <wall> (209)\n<floor> (206) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<floor> (77) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <drawing> (239)\n<phone> (247) is NEAR to <wall> (211)\n<phone> (247) is NEAR to <ceiling> (95)\n<powersocket> (246) is NEAR to <phone> (247)\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (206)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "241_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['MOVABLE', 'CONTAINERS', 'CAN_OPEN']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nwall_clock, id: 249, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<drawing> (240) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (216)\n<wall> (84) is NEAR to <phone> (247)\n<drawing> (174) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall_clock> (249)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <door> (222)\n<doorjamb> (165) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <drawing> (240)\n<trashcan> (99) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <drawing> (174)\n<ceiling> (217) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (245)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <floor> (202)\n<floor> (203) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (238)\n<light> (245) is NEAR to <phone> (247)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n<door> (222) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <ceiling> (217)\n<phone> (247) is NEAR to <trashcan> (99)\n<phone> (247) is NEAR to <ceiling> (94)\n<phone> (247) is NEAR to <wall> (209)\n<floor> (206) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<floor> (77) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <drawing> (239)\n<phone> (247) is NEAR to <wall> (211)\n<phone> (247) is NEAR to <ceiling> (95)\n<powersocket> (246) is NEAR to <phone> (247)\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (206)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "264_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nshoe-shine_kit, id: 2002, properties: ['CAN_OPEN', 'MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<phone> (1000) is ON to <desk> (357)\n<phone> (1000) is NEAR to <desk> (357)\n<character> (65) is INSIDE to <bathroom> (1)\n<desk> (357) is NEAR to <phone> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "265_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nbutton, id: 1001, properties: ['MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<phone> (1000) is NEAR to <button> (1001)\n<character> (65) is INSIDE to <bathroom> (1)\n<button> (1001) is NEAR to <phone> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "287_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['MOVABLE', 'CONTAINERS', 'CAN_OPEN']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nwall_clock, id: 249, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<drawing> (240) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (216)\n<wall> (84) is NEAR to <phone> (247)\n<drawing> (174) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall_clock> (249)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <door> (222)\n<doorjamb> (165) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <drawing> (240)\n<trashcan> (99) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <drawing> (174)\n<ceiling> (217) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (245)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <floor> (202)\n<floor> (203) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (238)\n<light> (245) is NEAR to <phone> (247)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n<door> (222) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <ceiling> (217)\n<phone> (247) is NEAR to <trashcan> (99)\n<phone> (247) is NEAR to <ceiling> (94)\n<phone> (247) is NEAR to <wall> (209)\n<floor> (206) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<floor> (77) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <drawing> (239)\n<phone> (247) is NEAR to <wall> (211)\n<phone> (247) is NEAR to <ceiling> (95)\n<powersocket> (246) is NEAR to <phone> (247)\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (206)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "352_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntable, id: 226, properties: ['MOVABLE', 'SURFACES']\ntrashcan, id: 99, properties: ['MOVABLE', 'CONTAINERS', 'CAN_OPEN']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nmat, id: 236, properties: ['LIEABLE', 'SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndrawing, id: 174, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nwall_clock, id: 249, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<drawing> (240) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (216)\n<wall> (84) is NEAR to <phone> (247)\n<drawing> (174) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall_clock> (249)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <door> (222)\n<doorjamb> (165) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <drawing> (240)\n<trashcan> (99) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <drawing> (174)\n<ceiling> (217) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (245)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <floor> (202)\n<floor> (203) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (238)\n<light> (245) is NEAR to <phone> (247)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n<door> (222) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <ceiling> (217)\n<phone> (247) is NEAR to <trashcan> (99)\n<phone> (247) is NEAR to <ceiling> (94)\n<phone> (247) is ON to <table> (226)\n<phone> (247) is NEAR to <wall> (209)\n<floor> (206) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<floor> (77) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <drawing> (239)\n<phone> (247) is NEAR to <wall> (211)\n<phone> (247) is NEAR to <ceiling> (95)\n<powersocket> (246) is NEAR to <phone> (247)\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (206)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "360_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "388_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "431_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nphone, states: ['OFF', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "436_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "442_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['MOVABLE', 'CONTAINERS', 'CAN_OPEN']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nwall_clock, id: 249, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<drawing> (240) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (216)\n<wall> (84) is NEAR to <phone> (247)\n<drawing> (174) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall_clock> (249)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <door> (222)\n<doorjamb> (165) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <drawing> (240)\n<trashcan> (99) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <drawing> (174)\n<ceiling> (217) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (245)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <floor> (202)\n<floor> (203) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (238)\n<light> (245) is NEAR to <phone> (247)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n<door> (222) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <ceiling> (217)\n<phone> (247) is NEAR to <trashcan> (99)\n<phone> (247) is NEAR to <ceiling> (94)\n<phone> (247) is NEAR to <wall> (209)\n<floor> (206) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<floor> (77) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <drawing> (239)\n<phone> (247) is NEAR to <wall> (211)\n<phone> (247) is NEAR to <ceiling> (95)\n<powersocket> (246) is NEAR to <phone> (247)\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (206)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "474_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['MOVABLE', 'CONTAINERS', 'CAN_OPEN']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nwall_clock, id: 249, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<drawing> (240) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (216)\n<wall> (84) is NEAR to <phone> (247)\n<drawing> (174) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall_clock> (249)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <door> (222)\n<doorjamb> (165) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <drawing> (240)\n<trashcan> (99) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <drawing> (174)\n<ceiling> (217) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (245)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <floor> (202)\n<floor> (203) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (238)\n<light> (245) is NEAR to <phone> (247)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n<door> (222) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <ceiling> (217)\n<phone> (247) is NEAR to <trashcan> (99)\n<phone> (247) is NEAR to <ceiling> (94)\n<phone> (247) is NEAR to <wall> (209)\n<floor> (206) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<floor> (77) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <drawing> (239)\n<phone> (247) is NEAR to <wall> (211)\n<phone> (247) is NEAR to <ceiling> (95)\n<powersocket> (246) is NEAR to <phone> (247)\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (206)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "482_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nbathroom, id: 1, properties: []\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['MOVABLE', 'CONTAINERS', 'CAN_OPEN']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nwall_clock, id: 249, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<drawing> (240) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (216)\n<wall> (84) is NEAR to <phone> (247)\n<drawing> (174) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall_clock> (249)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <door> (222)\n<doorjamb> (165) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <drawing> (240)\n<trashcan> (99) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <drawing> (174)\n<ceiling> (217) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (245)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <floor> (202)\n<floor> (203) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (238)\n<light> (245) is NEAR to <phone> (247)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n<door> (222) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (76)\n<character> (65) is INSIDE to <bathroom> (1)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <ceiling> (217)\n<phone> (247) is NEAR to <trashcan> (99)\n<phone> (247) is NEAR to <ceiling> (94)\n<phone> (247) is NEAR to <wall> (209)\n<floor> (206) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<floor> (77) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <drawing> (239)\n<phone> (247) is NEAR to <wall> (211)\n<phone> (247) is NEAR to <ceiling> (95)\n<powersocket> (246) is NEAR to <phone> (247)\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (206)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "497_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nhair, id: 2005, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "553_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "601_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 94, properties: []\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['MOVABLE', 'CONTAINERS', 'CAN_OPEN']\ndoorjamb, id: 165, properties: []\nbutton, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 241, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 242, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 243, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 248, properties: ['HAS_SWITCH', 'HAS_PLUG', 'LOOKABLE']\nwall_clock, id: 249, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<drawing> (240) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (216)\n<wall> (84) is NEAR to <phone> (247)\n<drawing> (174) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall_clock> (249)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <door> (222)\n<doorjamb> (165) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is FACING to <drawing> (243)\n<phone> (247) is FACING to <television> (248)\n<phone> (247) is NEAR to <drawing> (240)\n<trashcan> (99) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <drawing> (174)\n<ceiling> (217) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (245)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <floor> (202)\n<floor> (203) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (238)\n<light> (245) is NEAR to <phone> (247)\n<phone> (247) is FACING to <wall_clock> (249)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n<door> (222) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is FACING to <drawing> (242)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <ceiling> (217)\n<phone> (247) is NEAR to <trashcan> (99)\n<phone> (247) is FACING to <drawing> (241)\n<phone> (247) is NEAR to <ceiling> (94)\n<phone> (247) is NEAR to <wall> (209)\n<floor> (206) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<floor> (77) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <drawing> (239)\n<phone> (247) is NEAR to <wall> (211)\n<phone> (247) is NEAR to <ceiling> (95)\n<powersocket> (246) is NEAR to <phone> (247)\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (206)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "70_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nfork, id: 2008, properties: ['MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nphone, states: ['CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<phone> (1000) is ON to <desk> (357)\n<phone> (1000) is NEAR to <desk> (357)\n<desk> (357) is NEAR to <phone> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "864_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhair, id: 2004, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "963_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "974_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "976_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndesk, id: 357, properties: ['MOVABLE', 'SURFACES']\nphone, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 415, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nmousepad, id: 414, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<phone> (1000) is ON to <desk> (357)\n<phone> (1000) is NEAR to <desk> (357)\n<desk> (357) is NEAR to <phone> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "99_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 94, properties: []\nceiling, id: 95, properties: []\ntable, id: 226, properties: ['MOVABLE', 'SURFACES']\ntrashcan, id: 99, properties: ['MOVABLE', 'CONTAINERS', 'CAN_OPEN']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nmat, id: 236, properties: ['LIEABLE', 'SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ndrawing, id: 174, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'GRABBABLE', 'MOVABLE', 'LOOKABLE', 'CUTTABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'HAS_PLUG', 'MOVABLE', 'GRABBABLE']\nwall_clock, id: 249, properties: ['GRABBABLE', 'HAS_PLUG', 'MOVABLE', 'HAS_SWITCH', 'LOOKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<drawing> (240) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (216)\n<wall> (84) is NEAR to <phone> (247)\n<drawing> (174) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <table> (226)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <door> (222)\n<doorjamb> (165) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <drawing> (240)\n<trashcan> (99) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <drawing> (174)\n<ceiling> (217) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (245)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <floor> (202)\n<floor> (203) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (238)\n<light> (245) is NEAR to <phone> (247)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n<door> (222) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (76)\n<table> (226) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <ceiling> (217)\n<phone> (247) is NEAR to <trashcan> (99)\n<phone> (247) is NEAR to <ceiling> (94)\n<phone> (247) is ON to <table> (226)\n<phone> (247) is NEAR to <wall> (209)\n<floor> (206) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<floor> (77) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <drawing> (239)\n<phone> (247) is NEAR to <wall> (211)\n<phone> (247) is NEAR to <ceiling> (95)\n<powersocket> (246) is NEAR to <phone> (247)\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (206)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "183_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncoffe_maker, id: 290, properties: ['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\ncoffee_filter, id: 1000, properties: ['HAS_PAPER', 'MOVABLE', 'GRABBABLE']\nground_coffee, id: 1001, properties: ['CAN_OPEN', 'MOVABLE', 'GRABBABLE']\nwater, id: 1002, properties: ['DRINKABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncoffe_maker, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\n\nEdges:\n<coffee_filter> (1000) is INSIDE to <coffe_maker> (290)\n<coffe_maker> (290) is NEAR to <water> (1002)\n<ground_coffee> (1001) is INSIDE to <coffe_maker> (290)\n<character> (65) is INSIDE to <bathroom> (1)\n<water> (1002) is NEAR to <coffe_maker> (290)\n-----------------\n\n\nNode goals are:\ncoffe_maker is CLOSED\ncoffe_maker is ON\ncoffe_maker is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncoffee_filter is ON to coffe_maker\nground_coffee is ON to coffe_maker\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nPOUR\nPOUR\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "229_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncoffe_maker, id: 290, properties: ['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\ncoffee_filter, id: 1000, properties: ['HAS_PAPER', 'MOVABLE', 'GRABBABLE']\nground_coffee, id: 1001, properties: ['CAN_OPEN', 'MOVABLE', 'GRABBABLE']\nwater, id: 1002, properties: ['DRINKABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncoffe_maker, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\n\nEdges:\n<coffee_filter> (1000) is INSIDE to <coffe_maker> (290)\n<coffe_maker> (290) is NEAR to <water> (1002)\n<ground_coffee> (1001) is INSIDE to <coffe_maker> (290)\n<character> (65) is INSIDE to <bedroom> (67)\n<water> (1002) is NEAR to <coffe_maker> (290)\n-----------------\n\n\nNode goals are:\ncoffe_maker is CLOSED\ncoffe_maker is ON\ncoffe_maker is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncoffee_filter is ON to coffe_maker\nground_coffee is ON to coffe_maker\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nPOUR\nPOUR\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "310_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncoffe_maker, id: 290, properties: ['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\ncoffee_filter, id: 1000, properties: ['HAS_PAPER', 'MOVABLE', 'GRABBABLE']\nground_coffee, id: 1001, properties: ['CAN_OPEN', 'MOVABLE', 'GRABBABLE']\nwater, id: 1002, properties: ['DRINKABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncoffe_maker, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\n\nEdges:\n<coffe_maker> (290) is NEAR to <water> (1002)\n<ground_coffee> (1001) is INSIDE to <coffe_maker> (290)\n<character> (65) is INSIDE to <bathroom> (1)\n<water> (1002) is NEAR to <coffe_maker> (290)\n<coffee_filter> (1000) is NEAR to <ground_coffee> (1001)\n<ground_coffee> (1001) is NEAR to <coffee_filter> (1000)\n-----------------\n\n\nNode goals are:\ncoffe_maker is CLOSED\ncoffe_maker is ON\ncoffe_maker is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncoffee_filter is ON to coffe_maker\nground_coffee is ON to coffe_maker\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nPOUR\nPOUR\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "721_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncoffe_maker, id: 290, properties: ['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\nwater, id: 1000, properties: ['DRINKABLE', 'POURABLE']\ncoffee_filter, id: 1001, properties: ['HAS_PAPER', 'MOVABLE', 'GRABBABLE']\nground_coffee, id: 1002, properties: ['CAN_OPEN', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncoffe_maker, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_OUT'], properties:['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\n\nEdges:\n<water> (1000) is NEAR to <ground_coffee> (1002)\n<coffee_filter> (1001) is INSIDE to <coffe_maker> (290)\n<ground_coffee> (1002) is INSIDE to <coffe_maker> (290)\n<coffe_maker> (290) is NEAR to <water> (1000)\n<ground_coffee> (1002) is NEAR to <water> (1000)\n<water> (1000) is NEAR to <coffee_filter> (1001)\n<water> (1000) is NEAR to <coffe_maker> (290)\n<coffee_filter> (1001) is NEAR to <water> (1000)\n-----------------\n\n\nNode goals are:\ncoffe_maker is CLOSED\ncoffe_maker is ON\ncoffe_maker is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nground_coffee is ON to coffe_maker\ncoffee_filter is ON to coffe_maker\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nPOUR\nPOUR\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "764_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncoffe_maker, id: 290, properties: ['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\ncoffee_filter, id: 1000, properties: ['HAS_PAPER', 'MOVABLE', 'GRABBABLE']\nground_coffee, id: 1001, properties: ['CAN_OPEN', 'MOVABLE', 'GRABBABLE']\nwater, id: 1002, properties: ['DRINKABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncoffe_maker, states: ['OFF', 'CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_PLUG', 'MOVABLE', 'CAN_OPEN', 'HAS_SWITCH', 'RECIPIENT']\n\nEdges:\n<coffee_filter> (1000) is INSIDE to <coffe_maker> (290)\n<coffe_maker> (290) is NEAR to <water> (1002)\n<ground_coffee> (1001) is INSIDE to <coffe_maker> (290)\n<character> (65) is INSIDE to <bathroom> (1)\n<water> (1002) is NEAR to <coffe_maker> (290)\n-----------------\n\n\nNode goals are:\ncoffe_maker is CLOSED\ncoffe_maker is ON\ncoffe_maker is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncoffee_filter is ON to coffe_maker\nground_coffee is ON to coffe_maker\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nPOUR\nPOUR\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "419_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntable, id: 226, properties: ['MOVABLE', 'SURFACES']\nbedroom, id: 67, properties: []\nchair, id: 1000, properties: ['SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\ncloth_napkin, id: 1001, properties: ['HAS_PAPER', 'GRABBABLE', 'COVER_OBJECT', 'MOVABLE', 'CUTTABLE']\nplate, id: 1002, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nknife, id: 1003, properties: ['MOVABLE', 'GRABBABLE']\nmat, id: 236, properties: ['LIEABLE', 'SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nfork, id: 1004, properties: ['MOVABLE', 'GRABBABLE']\ncup, id: 1005, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncloth_napkin is ON to table\nplate is ON to table\nfork is ON to table\ncup is ON to table\nknife is ON to table\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "446_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntable, id: 226, properties: ['MOVABLE', 'SURFACES']\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nplate, id: 1000, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nplate, id: 1001, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nmat, id: 236, properties: ['LIEABLE', 'SURFACES', 'GRABBABLE', 'MOVABLE', 'SITTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncupboard, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<cupboard> (229) is NEAR to <plate> (1001)\n<plate> (1001) is INSIDE to <cupboard> (229)\n<plate> (1000) is INSIDE to <cupboard> (229)\n<character> (65) is INSIDE to <home_office> (319)\n<plate> (1001) is NEAR to <cupboard> (229)\n<plate> (1000) is NEAR to <cupboard> (229)\n<cupboard> (229) is NEAR to <plate> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nplate is ON to table\nplate is ON to table\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "710_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntable, id: 226, properties: ['MOVABLE', 'SURFACES']\nbathroom, id: 1, properties: []\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'CAN_OPEN', 'SURFACES']\ndining_room, id: 201, properties: []\nplate, id: 1001, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nkitchen_cabinet, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN', 'SURFACES']\n\nEdges:\n<kitchen_cabinet> (1000) is NEAR to <plate> (1001)\n<plate> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<plate> (1001) is NEAR to <kitchen_cabinet> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nplate is ON to table\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "84_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SURFACES', 'LIEABLE', 'MOVABLE', 'SITTABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntable, id: 355, properties: ['MOVABLE', 'SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "93_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nhair, id: 2000, properties: ['CUTTABLE', 'GRABBABLE', 'MOVABLE', 'BODY_PART']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "368_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncloth_napkin, id: 1000, properties: ['HAS_PAPER', 'GRABBABLE', 'COVER_OBJECT', 'MOVABLE', 'CUTTABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is INSIDE to dining_room\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "729_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nshower, id: 36, properties: []\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to shower\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "975_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nshower, id: 36, properties: []\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to shower\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "231_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nplate, id: 1000, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndish_soap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\nwater, id: 1002, properties: ['DRINKABLE', 'POURABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<plate> (1000) is NEAR to <water> (1002)\n<character> (65) is INSIDE to <home_office> (319)\n<water> (1002) is NEAR to <plate> (1000)\n<plate> (1000) is NEAR to <dish_soap> (1001)\n<dish_soap> (1001) is NEAR to <plate> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "31_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\ndish_soap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\nbowl, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT']\nsponge, id: 1002, properties: ['MOVABLE', 'GRABBABLE']\ndishrack, id: 1003, properties: ['SURFACES', 'MOVABLE', 'GRABBABLE']\nplate, id: 1004, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nfaucet, id: 232, properties: ['HAS_SWITCH']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (231) is NEAR to <bowl> (1001)\n<dish_soap> (1000) is NEAR to <sink> (231)\n<sponge> (1002) is NEAR to <sink> (231)\n<bowl> (1001) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <dish_soap> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n<sink> (231) is NEAR to <sponge> (1002)\n<plate> (1004) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <plate> (1004)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "349_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nfaucet, id: 232, properties: ['HAS_SWITCH']\ndish_soap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\nplate, id: 1001, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nfaucet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\n\nEdges:\n<plate> (1001) is NEAR to <faucet> (232)\n<dish_soap> (1000) is NEAR to <faucet> (232)\n<character> (65) is INSIDE to <bathroom> (1)\n<faucet> (232) is NEAR to <dish_soap> (1000)\n<faucet> (232) is NEAR to <plate> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "397_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndish_soap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\ndining_room, id: 201, properties: []\nplate, id: 1001, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "429_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\ndish_soap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "553_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\nplate, id: 1000, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nwater, id: 1002, properties: ['DRINKABLE', 'POURABLE']\ndining_room, id: 201, properties: []\nfood_kiwi, id: 2007, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nfood_food, id: 2009, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncupboard, states: ['CLOSED', 'CLEAN'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<food_food> (2009) is ON to <plate> (1000)\n<plate> (1000) is ON to <sink> (231)\n<sink> (231) is NEAR to <soap> (1001)\n<plate> (1000) is NEAR to <sink> (231)\n<soap> (1001) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <plate> (1000)\n<plate> (1000) is NEAR to <food_food> (2009)\n<character> (65) is INSIDE to <home_office> (319)\n<food_kiwi> (2007) is ON to <plate> (1000)\n<plate> (1000) is NEAR to <food_kiwi> (2007)\n<food_kiwi> (2007) is NEAR to <plate> (1000)\n<food_food> (2009) is NEAR to <plate> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "594_2",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndish_soap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\nplate, id: 1001, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\nsink, id: 42, properties: ['CONTAINERS', 'RECIPIENT']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<dish_soap> (1000) is NEAR to <sink> (42)\n<dish_soap> (1000) is ON to <sink> (42)\n<sink> (42) is NEAR to <dish_soap> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "746_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\ndish_soap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\nwater, id: 1001, properties: ['DRINKABLE', 'POURABLE']\nsponge, id: 1002, properties: ['MOVABLE', 'GRABBABLE']\ndrinking_glass, id: 1003, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT', 'POURABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sponge> (1002) is NEAR to <water> (1001)\n<character> (65) is INSIDE to <home_office> (319)\n<water> (1001) is NEAR to <sponge> (1002)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "961_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['CONTAINERS', 'RECIPIENT']\nplate, id: 1000, properties: ['SURFACES', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\ndish_soap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE', 'POURABLE']\ndishrack, id: 1002, properties: ['SURFACES', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nfood_kiwi, id: 2003, properties: ['GRABBABLE', 'MOVABLE', 'CUTTABLE', 'EATABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (231) is NEAR to <dish_soap> (1001)\n<food_kiwi> (2003) is ON to <plate> (1000)\n<plate> (1000) is NEAR to <sink> (231)\n<dish_soap> (1001) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <plate> (1000)\n<plate> (1000) is NEAR to <food_kiwi> (2003)\n<character> (65) is INSIDE to <bathroom> (1)\n<food_kiwi> (2003) is NEAR to <plate> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    },
    {
        "identifier": "988_1",
        "llm_prompt": "\nThe task is to guide the robot to take actions from the current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in JSON format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\nAction commands include action names and objects. Each action's number of objects is fixed (0, 1, or 2), and the output should include object names followed by their IDs:\n[]: Represents 0 objects.\n[object, object_id]: Represents 1 object.\n[object 1, object_1_id, object 2, object_2_id]: Represents 2 objects.\nThe output must be in JSON format, where:\nDictionary keys are action names.\nDictionary values are lists containing the objects (with their IDs) for the corresponding action.\nThe order of execution is determined by the order in which the key-value pairs appear in the JSON dictionary.\n\nFor example, If you want to first FIND the sink and then PUTBACK a cup into the sink, you should express it as:\n{\n  \"FIND\": [\"sink\", \"sink_id\"],\n  \"PUTBACK\": [\"cup\", \"cup_id\", \"sink\", \"sink_id\"]\n}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice:\n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. Output only object names and their IDs, not just the names.\n\n7. Output should not be empty! Always output some actions and their arguments.\n\n8. If you want to apply an action on an object, you should WALK to the object first.\n\n9. If you can't determine which room an object belongs in based on common sense, please FIND <object_name> first instead of WALK <object_name> directly.\n\n10. If the object is PLUGGED_IN,you need not PLUGIN.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfaucet, id: 232, properties: ['HAS_SWITCH']\ncharacter, id: 65, properties: []\nbowl, id: 1001, properties: ['GRABBABLE', 'MOVABLE', 'RECIPIENT']\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\n-----------------\n\n\nThe current environment state is\nNodes:\nfaucet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:\n"
    }
]